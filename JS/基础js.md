# 基础js

## **ECMAScript**

​		ECMAScript 是由ECMA 国际（ 原欧洲计算机制造商协会）进行标准化的一门编程语言，这种语言在万维网上应用广泛，它往往被称为 JavaScript或 JScript，但实际上后两者是 ECMAScript 语言的实现和扩展。

## **DOM——文档对象模型**

​		**文档对象模型**（DocumentObject Model，简称DOM），是W3C组织推荐的处理可扩展标记语言的标准编程接口。通过 DOM 提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色等）

## **BOM——浏览器对象模型**

​		**浏览器对象模型**(Browser Object Model，简称BOM) 是指浏览器对象模型，它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。

## 运算符

### 算数运算符

概念：算术运算使用的符号，用于执行两个变量或值的算术运算。

浮点数的精度问题

浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。

```js
var result = 0.1 + 0.2;    // 结果不是 0.3，而是：0.30000000000000004
console.log(0.07 * 100);   // 结果不是 7，  而是：7.000000000000001
```

所以：不要直接判断两个浮点数是否相等 ! 

### 递增和递减运算符

**前置递增运算符**

```
++num 前置递增，就是自加1，类似于 num =  num + 1，但是 ++num 写起来更简单。

使用口诀：先自加，后返回值
```

```javascript
var  num = 10;
alert(++num + 10);   // 21
```

**后置递增运算符**

num++ 后置递增，就是自加1，类似于 num =  num + 1 ，但是 num++ 写起来更简单。

使用口诀：先返回原值，后自加 

```js
var  num = 10;
alert(10 + num++);  // 20
```

### 短路运算（逻辑中断）

- 逻辑与

  语法： 表达式1 && 表达式2

  ```
  - 如果第一个表达式的值为真，则返回表达式2
  
  - 如果第一个表达式的值为假，则返回表达式1
  ```

  ```js
  console.log( 123 && 456 );        // 456
  console.log( 0 && 456 );          // 0
  console.log( 123 && 456&& 789 );  // 789
  ```

- 逻辑或

  语法： 表达式1 || 表达式2

  ```
  - 如果第一个表达式的值为真，则返回表达式1
  
  - 如果第一个表达式的值为假，则返回表达式2
  ```

  ```js
   console.log( 123 || 456 );         //  123
   console.log( 0 ||  456 );          //  456
   console.log( 123 || 456 || 789 );  //  123
  ```

  ### 运算符优先级

  ![](C:/Users/acer/Desktop/again/JS/images/图片10.png)

  - 一元运算符里面的逻辑非优先级很高
  - 逻辑与比逻辑或优先级高

## 流程控制

### 三元表达式

- 语法结构

  ```js
  表达式1 ? 表达式2 : 表达式3;
  ```

- 执行思路

  - 如果表达式1为 true ，则返回表达式2的值，如果表达式1为 false，则返回表达式3的值
  - 简单理解： 就类似于  if  else （双分支） 的简写

### switch分支流程控制

- 语法结构

  switch 语句也是多分支语句，它用于基于不同的条件来执行不同的代码。当要针对变量设置一系列的特定值的选项时，就可以使用 switch。

  ```js
  switch( 表达式 ){ 
      case value1:
          // 表达式 等于 value1 时要执行的代码
          break;
      case value2:
          // 表达式 等于 value2 时要执行的代码
          break;
      default:
          // 表达式 不等于任何一个 value 时要执行的代码
  }
  ```

  

## 循环

### 双重 for 循环语法

```js
for (外循环的初始; 外循环的条件; 外循环的操作表达式) {
    for (内循环的初始; 内循环的条件; 内循环的操作表达式) {  
       需执行的代码;
   }
}
```

**外层循环执行一次，内层循环要执行全部次数**

**打印五行五列星星**

```js
var star = '';
for (var j = 1; j <= 3; j++) {
    for (var i = 1; i <= 3; i++) {
      star += '☆'
    }
    // 每次满 5个星星 就 加一次换行
    star += '\n'
}
console.log(star);
```

## 数组

### 创建数组

JS 中创建数组有两种方式：

- 利用  new 创建数组  

  ```js
  var 数组名 = new Array() ；
  var arr = new Array();   // 创建一个新的空数组
  ```

  注意 Array () ，A 要大写    

- 利用数组字面量创建数组

  ```js
  //1. 使用数组字面量方式创建空的数组
  var  数组名 = []；
  //2. 使用数组字面量方式创建带初始值的数组
  var  数组名 = ['小白','小黑','大黄','瑞奇'];
  ```

- 数组元素的类型

  数组中可以存放任意类型的数据，例如字符串，数字，布尔值等。

  ```js
  var arrStus = ['小白',12,true,28.9];
  ```

### 遍历数组

- 数组遍历

  ​		把数组中的每个元素从头到尾都访问一次（类似学生的点名），可以通过 for 循环索引遍历数组中的每一项


```js
var arr = ['red','green', 'blue'];
for(var i = 0; i < arr.length; i++){
    console.log(arrStus[i]);
}
```

### 数组中新增元素

​		数组中可以通过以下方式在数组的末尾插入新元素：

```js
  数组[ 数组.length ] = 新数据;
```

## 函数

###  函数的参数

#### 函数参数语法

- 形参：函数定义时设置接收调用时传入

- 实参：函数调用时传入小括号内的真实数据

  ![](C:/Users/acer/Desktop/again/JS/images/图片3.png)

  ​	参数的作用 : 在函数内部某些值不能固定，我们可以通过参数在调用函数时传递不同的值进去。

  函数参数的运用：

  ```js
  // 带参数的函数声明
  function 函数名(形参1, 形参2 , 形参3...) { // 可以定义任意多的参数，用逗号分隔
    // 函数体
  }
  // 带参数的函数调用
  函数名(实参1, 实参2, 实参3...); 
  ```

### arguments的使用

​		当不确定有多少个参数传递的时候，可以用 arguments 来获取。JavaScript 中，arguments实际上它是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参。arguments展示形式是一个伪数组，因此可以进行遍历。伪数组具有以下特点：

- 具有 length 属性

- 按索引方式储存数据

- 不具有数组的 push , pop 等方法

  注意：在函数内部使用该对象，用此对象获取函数调用时传的实参。

### 函数的两种声明方式

自定义函数方式(命名函数)

利用函数关键字 function 自定义函数方式

```js
// 声明定义方式
function fn() {...}
// 调用  
fn();  
```

- 因为有名字，所以也被称为命名函数
- 调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面

函数表达式方式(匿名函数）

利用函数表达式方式的写法如下： 

```js
// 这是函数表达式写法，匿名函数后面跟分号结束
var fn = function(){...}；
// 调用的方式，函数调用必须写到函数体下面
fn();
```

- 因为函数没有名字，所以也被称为匿名函数
- 这个fn 里面存储的是一个函数  
- 函数表达式方式原理跟声明变量方式是一致的
- 函数调用的代码必须写到函数体后面

## 作用域

JavaScript（es6前）中的作用域有两种：

- 全局作用域
- 局部作用域（函数作用域）	

### 全局作用域

		作用于所有代码执行的环境(整个script标签内部)或独立的js文件。

### 局部作用域

		作用于函数内的代码环境，就是局部作用域。 
		因为跟函数有关系，所以也称为函数作用域。

### 作用域链

只要是代码都一个作用域中，写在函数内部的局部作用域，未写在任何函数内部即在全局作用域中；如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域；根据在**[内部函数可以访问外部函数变量]**的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作作用域链。

```javascript
作用域链：采取就近原则的方式来查找变量最终的值
var a = 1;
function fn1() {
    var a = 2;
    var b = '22';
    fn2();
    function fn2() {
        var a = 3;
        fn3();
        function fn3() {
            var a = 4;
            console.log(a); //a的值 ?
            console.log(b); //b的值 ?
        }
    }
}
fn1();
```

## 预解析

- 预解析：在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和 function 声明的变量在内存中进行提前声明或者定义，预解析也叫做变量、函数提升。

- 代码执行： 从上到下执行JS语句。

注意：**预解析会把变量和函数的声明在代码执行之前执行完成。**

###  变量预解析

​	变量的声明会被提升到当前作用域的最上面，变量的赋值不会提升。

```js
console.log(num);  // 结果是多少？
var num = 10;      // ？
```

结果：undefined
注意：**变量提升只提升声明，不提升赋值**

###  函数预解析

​	 函数的声明会被提升到当前作用域的最上面，但是不会调用函数。

```js
fn();
function fn() {
    console.log('打印');
}
```

结果：控制台打印字符串 --- ”打印“ 

注意：函数声明代表函数整体，所以函数提升后，函数名代表整个函数，但是函数并没有被调用！	

### 函数表达式声明函数问题

函数表达式创建函数，会执行变量提升

```js
fn();
var  fn = function() {
    console.log('想不到吧');
}
```

结果：报错提示 ”fn is not a function"

解释：该段代码执行之前，会做变量声明提升，fn在提升之后的值是undefined；而fn调用是在fn被赋值为函数体之前，此时fn的值是undefined，所以无法正确调用

## 对象

### 创建对象的三种方式

#### 利用字面量创建对象 

```
	花括号 { } 里面包含了表达这个具体事物（对象）的属性和方法；{ } 里面采取键值对的形式表示 
```

- 键：相当于属性名

- 值：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函数类型等）

  代码如下：

  ```js
  var star = {
      name : 'pink',
      age : 18,
      sex : '男',
      sayHi : function(){
          alert('大家好啊~');
      }
  };
  ```

  上述代码中 star即是创建的对象。

#### 利用 new Object 创建对象 

- 创建空对象

  ```js
  var andy = new Obect();
  ```

  通过内置构造函数Object创建对象，此时andy变量已经保存了创建出来的空对象

- 给空对象添加属性和方法

  - 通过对象操作属性和方法的方式，来为对象增加属性和方法

    示例代码如下：

  ```js
  andy.name = 'pink';
  andy.age = 18;
  andy.sex = '男';
  andy.sayHi = function(){
      alert('大家好啊~');
  }
  ```

  注意：

  - Object() ：第一个字母大写   
  - new Object() ：需要 new 关键字
  - 使用的格式：对象.属性 =  值;     

#### 利用构造函数创建对象

- 构造函数

  - 构造函数：是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。

  - 构造函数的封装格式：

    ```js
    function 构造函数名(形参1,形参2,形参3) {
         this.属性名1 = 参数1;
         this.属性名2 = 参数2;
         this.属性名3 = 参数3;
         this.方法名 = 函数体;
    }
    ```

  - 构造函数的调用格式

    ```
    var obj = new 构造函数名(实参1，实参2，实参3)
    ```

    以上代码中，obj即接收到构造函数创建出来的对象。

  - 注意事项

    1.   构造函数约定**首字母大写**。
    2.   函数内的属性和方法前面需要添加 **this** ，表示当前对象的属性和方法。
    3.   构造函数中**不需要 return 返回结果**。
    4.   当我们创建对象的时候，**必须用 new 来调用构造函数**。

  - 其他

    构造函数，如 Stars()，抽象了对象的公共部分，封装到了函数里面，它泛指某一大类（class）  
    创建对象，如 new Stars()，特指某一个，通过 new 关键字创建对象的过程我们也称为对象实例化

- **new关键字的作用**

  1. 在构造函数代码开始执行之前，创建一个空对象；
  2. 修改this的指向，把this指向创建出来的空对象；
  3. 执行函数的代码
  4. 在函数完成之后，返回this---即创建出来的对象

### 遍历对象

​		for...in 语句用于对数组或者对象的属性进行循环操作。

​		其语法如下：

```js
for (变量 in 对象名字) {
    // 在此执行代码
}
```

​		语法中的变量是自定义的，它需要符合命名规范，通常我们会将这个变量写为 k 或者 key。

```js
for (var k in obj) {
    console.log(k);      // 这里的 k 是属性名
    console.log(obj[k]); // 这里的 obj[k] 是属性值
}
```

## 内置对象

### Math对象

**Math 对象不是构造函数**，它具有数学常数和函数的属性和方法。跟数学相关的运算（求绝对值，取整、最大值等）可以使用 Math 中的成员。

###  日期对象

​	Date 对象和 Math 对象不一样，Date是一个**构造函数**，所以使用时需要实例化后才能使用其中具体方法和属性。Date 实例用来处理日期和时间

使用Date实例化日期对象

- 获取当前时间必须实例化：

```js
var now = new Date();
```

- 获取指定时间的日期对象

```js
var future = new Date('2019/5/1');
```

注意：如果创建实例时并未传入参数，则得到的日期对象是当前时间对应的日期对象

- 通过Date实例获取总毫米数

  - 总毫秒数的含义

    ​	基于1970年1月1日（世界标准时间）起的毫秒数

  - 获取总毫秒数

    ```js
    // 实例化Date对象
    var now = new Date();
    // 1. 用于获取对象的原始值 时间戳
    console.log(date.valueOf())	
    console.log(date.getTime())	
    // 2. 简单写可以这么做
    var now = + new Date();			
    // 3. HTML5中提供的方法，有兼容性问题
    var now = Date.now();
    ```

### 数组对象

#### 创建数组的两种方式

- 字面量方式 

  - 示例代码如下：

    ```js
    var arr = [1,"test",true];
    ```

- new Array()

  - 示例代码如下：

    ```
    var arr = new Array();
    ```

    ​	注意：上面代码中arr创建出的是一个空数组，如果需要使用构造函数Array创建非空数组，可以在创建数组时传入参数

    ​	参数传递规则如下：

    - 如果只传入一个参数，则参数规定了数组的长度

    - 如果传入了多个参数，则参数称为数组的元素

#### 检测是否为数组

- instanceof 运算符

  - instanceof 可以判断一个对象是否是某个构造函数的实例

    ```js
    var arr = [1, 23];
    var obj = {};
    console.log(arr instanceof Array); // true
    console.log(obj instanceof Array); // false
    ```

- **Array.isArray()**

  - Array.isArray()用于判断一个对象是否为数组，isArray() 是 HTML5 中提供的方法

    ```js
    var arr = [1, 23];
    var obj = {};
    console.log(Array.isArray(arr));   // true
    console.log(Array.isArray(obj));   // false
    ```

#### 添加删除数组元素的方法

数组中有进行增加、删除元素的方法，部分方法如下表

添加

```javascript
arr.push(1,2,3);// 返回结果是数组的长度。
```

```javascript
arr.unshift('前面添加')//前面添加，返回结果也是数组的长度。
```

删除

```javascript
arr.pop();//删除最后一个元素，不带参数，返回值是删除的元素
```

```javascript
arr.shift();//删除第一个元素，不带参数，返回值是删除的元素
```

注意：push、unshift为增加元素方法；pop、shift为删除元素的方法

#### 数组排序

翻转数组

```javascript
arr.reverse();
```

冒泡排序

```javascript
arr.sort();//个位数排列。

//需要特殊写法（函数）
arr.sort(function(a,b){
    return a-b;//升序排序
    //
    return b-a;//降序排列
});
```

#### 获取数组元素索引

```javascript
//返回方法  indexOf(数组元素)
//只返回第一个满足要求的数组
//如果找不到元素返回-1
arr.indexOf('元素',[起始的位置]);//前往后查找
arr.lastIndexOf('元素')//后往前查找
```

#### 数组去重

核心算法：遍历旧数组，拿着旧数组元素去查询新数组，如果这个元素没有出现过，我们就添加进去 。

#### 数组转换字符串

```javascript
toString();//将我们的数组转换为字符串，1，2，3逗号分隔
join(分隔符);//数组之间分隔符隔开
```

注意：join方法如果不传入参数，则按照 “ , ”拼接元素

#### 数组截取

```javascript
arr.slice([begin[, end]])

var fruits = ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango'];
var citrus = fruits.slice(1, 3);

// fruits contains ['Banana', 'Orange', 'Lemon', 'Apple', 'Mango']
// citrus contains ['Orange','Lemon']
```

### 字符串对象

基本包装类型就是把简单数据类型包装成为复杂数据类型，这样基本数据类型就有了属性和方法。

为了方便操作基本数据类型，JavaScript 还提供了三个特殊的引用类型：String、Number和 Boolean。

```js
// 下面代码有什么问题？
var str = 'andy';
console.log(str.length);
```

​		按道理基本数据类型是没有属性和方法的，而对象才有属性和方法，但上面代码却可以执行，这是因为

​		js 会把基本数据类型包装为复杂数据类型，其执行过程如下 ：

```js
// 1. 生成临时变量，把简单类型包装为复杂数据类型
var temp = new String('andy');
// 2. 赋值给我们声明的字符变量
str = temp;
// 3. 销毁临时变量
temp = null;
```

#### 字符串的不可变

​		指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间。

​		当重新给字符串变量赋值的时候，变量之前保存的字符串不会被修改，依然在内存中重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变。
​		由于字符串的不可变，在**大量拼接字符串**的时候会有效率问题

#### 根据字符返回位置

​		字符串通过基本包装类型可以调用部分方法来操作字符串，以下是返回指定字符的位置的方法：

| 方法名                              | 说明                                                         |
| ----------------------------------- | ------------------------------------------------------------ |
| indexOf ('要查找的字符',开始的位置) | 返回指定内容在元字符串中的位置，如果找到就返回-1，开始的位置是index索引号 |
| lastindex()                         | 从后往前找，只找第一个匹配的                                 |

​		案例：查找字符串"abcoefoxyozzopp"中所有o出现的位置以及次数

1. 先查找第一个o出现的位置
2. 然后 只要indexOf 返回的结果不是 -1 就继续往后查找
3. 因为indexOf 只能查找到第一个，所以后面的查找，利用第二个参数，当前索引加1，从而继续查找 	

#### 根据位置返回字符

​		字符串通过基本包装类型可以调用部分方法来操作字符串，以下是根据位置返回指定位置上的字符：

| 方法名            | 说明                                     | 使用                         |
| ----------------- | ---------------------------------------- | ---------------------------- |
| charAt(index)     | 返回指定位置的字符(index 字符的索引号)   | str.charAt(0)                |
| charCodeAt(index) | 获取指定位置处字符的ASCII码(index索引号) | str.charCodeAt(0)            |
| str[index]        | 获取指定位置处字符                       | HTML5,IE8+支持和charAt()等效 |

案例：判断一个字符串 'abcoefoxyozzopp' 中出现次数最多的字符，并统计其次数

1. 核心算法：利用 charAt(） 遍历这个字符串

2. 把每个字符都存储给对象， 如果对象没有该属性，就为1，如果存在了就 +1

3. 遍历对象，得到最大值和该字符 	

   ​	注意：在遍历的过程中，把字符串中的每个字符作为对象的属性存储在对象总，对应的属性值是该字符出现的次数

   ```javascript
    		var obj = {};
           var strings = "abcdefffss";
           for (var i = 0; i < strings.length; i++) {
               var chats = strings.charAt(i)
               if (obj[chats]) {
                   obj[chats] += 1;
               } else {
                   obj[chats] = 1;
               }
           }
           console.log(obj);
   ```

#### 字符串操作方法

​		字符串通过基本包装类型可以调用部分方法来操作字符串，以下是部分操作方法：

截取字符串

```javascript
substr('截取的起始位置',' '截取几个字符');
```

##### replace()方法 替换

```javascript
str.replace('被替换的字符','替换为的字符');//只替换第一个
```

##### split()方法 分隔

```javascript
str.split('分隔符'); //数组的是join
```

## 简单数据类型和复杂数据类型

### 简单数据类型

简单类型（基本数据类型、值类型）：在存储时变量中存储的是值本身，包括stri复杂数据类型

###  复杂数据类型

复杂数据类型（引用类型）：在存储时变量中存储的仅仅是地址（引用），通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等；g ，number，boolean，undefined，null

### 堆栈

- 堆栈空间分配区别：

　　1、栈（操作系统）：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈；

简单数据类型存放到栈里面

　　2、堆（操作系统）：存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。

###  简单类型传参

​		函数的形参也可以看做是一个变量，当我们把一个值类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到的外部变量。

```js
function fn(a) {
    a++;
    console.log(a); //11
}
var x = 10;
fn(x);
console.log(x)；//10
```

### 复杂数据类型传参

​		函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。

```JavaScript
function Person(name) {
    this.name = name;
}
function f1(x) { // x = p
    console.log(x.name); // 2. 这个输出什么 ?    刘德华
    x.name = "张学友";
    console.log(x.name); // 3. 这个输出什么 ?    张学友
}
var p = new Person("刘德华");
console.log(p.name);    // 1. 这个输出什么 ? 刘德华  
f1(p);
console.log(p.name);    // 4. 这个输出什么 ?  张学友
```

